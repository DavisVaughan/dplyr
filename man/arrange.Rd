% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/arrange.R
\name{arrange}
\alias{arrange}
\alias{arrange.data.frame}
\title{Arrange rows by column values}
\usage{
arrange(.data, ..., .by_group = FALSE)

\method{arrange}{data.frame}(
  .data,
  ...,
  .by_group = FALSE,
  .method = c("dplyr_auto", "auto", "shell", "radix")
)
}
\arguments{
\item{.data}{A data frame, data frame extension (e.g. a tibble), or a
lazy data frame (e.g. from dbplyr or dtplyr). See \emph{Methods}, below, for
more details.}

\item{...}{<\code{\link[=dplyr_data_masking]{data-masking}}> Variables, or functions or
variables. Use \code{\link[=desc]{desc()}} to sort a variable in descending order.}

\item{.by_group}{If \code{TRUE}, will sort first by grouping variable. Applies to
grouped data frames only.}

\item{.method}{The underlying method to sort with. If \code{"radix"}, \code{"shell"},
or \code{"auto"}, the method is passed on to \code{\link[=order]{order()}} as is. If \code{"dplyr_auto"},
the method will be set to \code{"radix"} if all of the columns to arrange by are
internally integer, double, logical, or character, otherwise the method will
be set to \code{"shell"}.}
}
\value{
An object of the same type as \code{.data}. The output has the following
properties:
\itemize{
\item All rows appear in the output, but (usually) in a different place.
\item Columns are not modified.
\item Groups are not modified.
\item Data frame attributes are preserved.
}
}
\description{
\code{arrange()} order the rows of a data frame rows by the values of selected
columns.

Unlike other dplyr verbs, \code{arrange()} largely ignores grouping; you
need to explicit mention grouping variables (or use  \code{by_group = TRUE})
in order to group by them, and functions of variables are evaluated
once per data frame, not once per group.
}
\details{
\subsection{Locales}{

When \code{.method} is set to \code{"dplyr_auto"} or \code{"radix"}, the sort order for
character vectors always follows the "C" locale. Otherwise, the sort order
for character vectors will depend on the collating sequence of the locale
in use: see \code{\link[=locales]{locales()}}.
}

\subsection{Missing values}{

Unlike base sorting with \code{sort()}, \code{NA} are:
\itemize{
\item always sorted to the end for local data, even when wrapped with \code{desc()}.
\item treated differently for remote data, depending on the backend.
}
}
}
\section{Methods}{

This function is a \strong{generic}, which means that packages can provide
implementations (methods) for other classes. See the documentation of
individual methods for extra arguments and differences in behaviour.

The following methods are currently available in loaded packages:
\Sexpr[stage=render,results=rd]{dplyr:::methods_rd("arrange")}.
}

\examples{
arrange(mtcars, cyl, disp)
arrange(mtcars, desc(disp))

# grouped arrange ignores groups
by_cyl <- mtcars \%>\% group_by(cyl)
by_cyl \%>\% arrange(desc(wt))
# Unless you specifically ask:
by_cyl \%>\% arrange(desc(wt), .by_group = TRUE)

# use embracing when wrapping in a function;
# see ?dplyr_data_masking for more details
tidy_eval_arrange <- function(.data, var) {
  .data \%>\%
    arrange({{ var }})
}
tidy_eval_arrange(mtcars, mpg)

# use across() access select()-style semantics
iris \%>\% arrange(across(starts_with("Sepal")))
iris \%>\% arrange(across(starts_with("Sepal"), desc))
}
\seealso{
Other single table verbs: 
\code{\link{filter}()},
\code{\link{mutate}()},
\code{\link{rename}()},
\code{\link{select}()},
\code{\link{slice}()},
\code{\link{summarise}()}
}
\concept{single table verbs}
